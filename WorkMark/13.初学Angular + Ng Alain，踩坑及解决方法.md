# 13.初学Angular + Ng Alain，踩坑及解决方法

作者：罗永梅
时间：2019 年 06 月 12 日

### 一、Angular *ngFor 获取 index

普通遍历用法：
```
<ul>
　　<li *ngFor="let item in items">{{item}}</li>
</ul>
```
有时候需要获取index，可以这样用：
```
<ul>
    <li *ngFor="let item of items; let i = index">     
       {{ item }} 的索引是：{{ i }}
    </li>
</ul>
```

### 二、Angular *ngIf 和 else 的用法

```
<div *ngIf="condition; else elseBlock">...</div>
<ng-template #elseBlock>...</ng-template>
```

实例：
```
<span *ngIf="customPrevIcon === 'default'; else SetIcon1" class="ant-tabs-tab-prev-icon">
    <i nz-icon [type]="nzPositionMode === 'horizontal' ? 'left' : 'up'" class="ant-tabs-tab-prev-icon-target"></i>
</span>
<ng-template #SetIcon1>
    <span class="ant-tabs-tab-prev-icon">
        <i nz-icon [type]="customPrevIcon" class="ant-tabs-tab-prev-icon-target"></i>
    </span>
</ng-template>
```

### 三、Angular ng-container 和 ng-template 的用法

1. ng-container 是一个逻辑容器，可用于对节点进行分组，但不作为 DOM 树中的节点，标签在浏览器渲染后，不会显示。在我们需要遍历或if判断时，它可以承担一个载体的作用： 
```
<ul>
  <ng-container *ngFor="let item of items">
    <li>{{ item .name}}</li>
    <li>{{ item .age}}</li>
    <li>{{ item .sex}}</li>
  </ng-container>
</ul>
```

1. ng-template 使用 * 语法糖的结构指令，最终都会转换为 ng-template 或 template 模板指令，需要对模板内的内容进行处理才能显示在页面上： 

```
<ng-template>
   <p> ngIf with a ng-template.</p>  // 内容不会被浏览器渲染显示
</ng-template>
```

```
<ng-template [ngIf]="true">
   <p> ngIf with a ng-template.</p>  // 内容可渲染
</ng-template>
```

### 四、Rxjs6

Rxjs 是使用 Observables 的响应式编程的库，它使编写异步或基于回调的代码更容易。

#### （1）Rxjs异步通信之Subject和BehaviorSubject

1. Subject 可以实现一个消息向多个订阅者推送消息
```
var subject = new Rx.Subject();   //实例化一个Subject对象
subject.next(1);                  //向接受者发送一个消息流

subject.subscribe({
    next: (value) => console.log('observerA: ' + value)  //接受者A订阅消息，获取消息流中的数据
});
subject.subscribe({
    next: (value) => console.log('observerB: ' + value)  //接受者B订阅消息，获取消息流中的数据
});
```

这样两路接受者都能拿到发送的数据流:
```
observerA:1
observerB:1
```

2. BehaviorSubject 是 Subject 的一个衍生类，它将数据流中的最新值推送给接受者
```
var subject = new Rx.BehaviorSubject(0); //声明一个BehaviorSubject对象
subject.next(1);           //发送一个数据流
subject.next(2);           //再发送一个数据流
subject.subscribe({
    next: (v) => console.log('observerA: ' + v)  //接受者A订阅消息
});
subject.subscribe({
    next: (v) => console.log('observerB: ' + v)  //接受者B订阅消息
});
subject.next(3);    //再发送一个数据流

```

这样，每次接受者只会接受最新最送的那个消息：
```
observerA:2
observerB:2
observerA:3
observerB:3
```

#### （2）Rxjs6 升级使用区别

Rxjs 5 的版本是直接调用操作符，Rxjs 6 的操作符都放在 pipe (管道)中配置；Rxjs 6可直接使用fromEvent。

Rxjs 5：
```
import { Observable } from 'rxjs/Rx';

Observable.fromEvent(addBtn, 'click')
.throttleTime(3000) // 操作符
.subscribe(() => {
    nameInput.value = +(nameInput.value) + 1
})
```

Rxjs 6：
```
import { fromEvent } from 'rxjs';
import { throttleTime } from 'rxjs/operators'


fromEvent(addBtn, 'click')
.pipe(throttleTime(3000)) // 操作符
.subscribe(() => {
    nameInput.value = +(nameInput.value) + 1
})
```

### 五、使用 Ng Alain 时，由于请求改变后无法动态更新，导致侧边栏没有数据

解决方法：  
使用detectChanges强制更新数据：
```
import {
  Component,
  OnInit,
  ChangeDetectorRef,
} from '@angular/core';
import { MenuService } from '@delon/theme';

@Component({
  selector: 'header-menu',
  templateUrl: './menu.component.html',
  styleUrls: [`./menu.component.less`],
})
export class MenuComponent implements OnInit {
  constructor(
    public menuService: MenuService,
    private change: ChangeDetectorRef,
  ) {}

  ngOnInit(): void {
    this.menuService.change.subscribe(res => {
      this.change.detectChanges();
      console.log(res);
    });
  }
}
```

### 六、Property 'fromEvent' does not exist on type 'typeof Observable' 和 Property 'fromEvent' does not exist on type 'typeof Observable'
由于 rxjs6 升级所致：
```
import { Observable } from 'rxjs/Rx';

Observable.fromEvent(window, 'resize').subscribe((event) => {
  console.log('页面变化');
});
```
改成
```
import { fromEvent } from 'rxjs';

fromEvent(window,'resize').subscribe((event) => {
  console.log('页面变化');
});
```